# CREATIONAL DESIGN PATTERNS

The creational design patterns aim to enhance flexibility and promote the reuse of existing code by offering various mechanisms for creating objects.

## 🛠️ Factory Method

The **Factory Method** (also known as **Virtual Constructor**) is a creational design pattern that offers an interface for object creation in a superclass while allowing subclasses to modify the type of objects that are created. This design pattern structure requires four key elements for full implementation: the **Product Interface**, the **Concrete Product classes**, the **Creator class**, and the **Concrete Creator classes**.

- **Product Interface**: In this context, a _product_ is an object that can be generated by a factory method. This interface defines the methods that are common to all objects produced by the creator and its subclasses.

- **Concrete Product**: Specific implementations of the **Product Interface**, representing the actual objects created and returned by the factory method.

- **Creator Class**: Declares the factory method responsible for creating and returning new **Product** objects. The return type must conform to the **Product Interface**.

- **Concrete Creator**: Extends the base creator and overrides the factory method to return a specific type of **Product**.

### Dialog example

> TypeScript implementation of the pseudocode presented on pages 80 to 84 in *Dive Into Design Patterns* by Alexander Shvets. Refactoring.Guru, 2022. Available at: [https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book).

```typescript
// Product Interface
interface Button {
  render(): void;
  onClick(f: string): void;
}

// Creator
abstract class Dialog {
  abstract createButton(): Button;
  render(): void {
    const okButton: Button = this.createButton();
    okButton.onClick("Close Dialog");
    okButton.render();
  }
}

// Concrete implementations of Product Interface
class WindowsButton implements Button {
  render(): void {
    console.log("Windows button rendered.");
  }
  onClick(f: string): void {
    console.log(`Windows button clicked: ${f}`);
  }
}

class HTMLButton implements Button {
  render(): void {
    console.log("HTML button rendered.");
  }
  onClick(f: string): void {
    console.log(`HTML button clicked: ${f}`);
  }
}

// Concrete implementations of Creator
class WindowsDialog extends Dialog {
  createButton(): Button {
    return new WindowsButton();
  }
}

class WebDialog extends Dialog {
  createButton(): Button {
    return new HTMLButton();
  }
}

function readApplicationConfigFile() {
  const platforms = ["Windows", "Web"];
  return { OS: platforms[Math.floor(Math.random() * platforms.length)] };
}

// Usage in an application
class Application {
  dialog: Dialog;

  constructor() {
    const config = readApplicationConfigFile();

    if (config.OS === "Windows") {
      this.dialog = new WindowsDialog();
    } else if (config.OS === "Web") {
      this.dialog = new WebDialog();
    } else {
      throw new Error("Unknown operating system.");
    }
  }
}
```

In the example above, the abstract class `Dialog` serves as the **Creator class**, while `WindowsDialog` and `WebDialog` are its concrete implementations. Similarly, the `Button` class represents the **Product** interface, with `HTMLButton` and `WindowsButton` as its concrete variants. In this scenario, the application seamlessly adapts to the OS specified in its configuration. Notably, adding new dialog variants is straightforward—simply create a new concrete product class and override the methods defined in the `Button` interface.  

The Factory Method is well-suited for scenarios where:  

- The exact types and dependencies of the objects the code will work with are unknown in advance.  
- When providing users of a library or framework with a mechanism to extend its internal components.  
- When aiming to save system resources by reusing existing objects rather than rebuilding them each time. 

### Benefits and Drawbacks

- ✅ **Avoid tight coupling** between the creator and concrete products.
- ✅ **Single Responsibility Principle**: Centralizes product creation, making the code easier to maintain.
- ✅ **Open/Closed Principle**: Allows introducing new product types without modifying existing client code.
- ❌ **Increased complexity**: Requires introducing many new subclasses, which may complicate the codebase.

## 🏭 Abstract Factory

The **Abstract Factory** pattern is a creational design pattern that enables the creation of families of related objects without specifying their concrete classes. The **Abstract Factory** pattern is a creational design pattern that facilitates the creation of families of related objects without specifying their concrete classes. This pattern is particularly useful when working with products and their corresponding variants, such as UI components that need to be adapted for different operating systems. For example, an **Abstract Factory** can be used to create **buttons** and **checkboxes**, ensuring that a macOS application uses macOS-style UI elements while a Windows application uses Windows-style UI elements. This design pattern structure requires five key elements for full implementation: the Product Interface, the Concrete Product classes, the Creator class, and the Concrete Creator classes.


- **Abstract Products**: each **Abstract Product** defines an interface for a product, and together, these products compose a cohesive product family.
- **Concrete Implementations**: these are multiple implementations of the abstract products, categorized by variants. Each concrete product must have a corresponding implementation across all variants.
- **Abstract Factory**: an interface in which the set of methods for creating each abstract product must be declared.
- **Concrete Factories**: These are implementations of the methods defined in the Abstract Factory. There must be a separate concrete factory for each product variant, and each factory is only permitted to create products related to its specific variant.

**Note**: As long as the creation methods of concrete factories return the corresponding abstract products, the client code will remain decoupled from the specific variant of the product. The client can work with any concrete factory/product variant, interacting with them through their abstract interfaces. 

### GUI Factory example

> TypeScript implementation of the pseudocode presented on pages 98 to 101 in *Dive Into Design Patterns* by Alexander Shvets. Refactoring.Guru, 2022. Available at: [https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book).

```typescript
// Abstract Factory
interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

// Concrete Factories
class WinFactory implements GUIFactory {
  createButton() {
    return new WinButton();
  }
  createCheckbox() {
    return new WinCheckbox();
  }
}

class MacFactory implements GUIFactory {
  createButton() {
    return new MacButton();
  }
  createCheckbox() {
    return new MacCheckbox();
  }
}

// Product Interfaces
interface Button {
  paint(): void;
}

interface Checkbox {
  paint(): void;
}

// Concrete Products
class WinButton implements Button {
  paint(): void {
    console.log("Windows Button rendered!");
  }
}

class MacButton implements Button {
  paint(): void {
    console.log("Mac Button rendered!");
  }
}

class WinCheckbox implements Checkbox {
  paint(): void {
    console.log("Windows Checkbox rendered!");
  }
}

class MacCheckbox implements Checkbox {
  paint(): void {
    console.log("Mac Checkbox rendered!");
  }
}

// Client code working with abstract types
class Application {
  private factory: GUIFactory;
  private button!: Button;

  constructor(factory: GUIFactory) {
    this.factory = factory;
  }

  createUI() {
    this.button = this.factory.createButton();
  }

  paint() {
    this.button.paint();
  }
}

function readApplicationConfigFile() {
  const platforms = ["Windows", "Mac"];
  return { OS: platforms[Math.floor(Math.random() * platforms.length)] };
}

// Usage in application
class ApplicationConfigurator {
  main() {
    const config = readApplicationConfigFile();
    let factory = null;

    if (config.OS === "Windows") {
      factory = new WinFactory();
    } else if (config.OS === "Mac") {
      factory = new MacFactory();
    } else {
      throw new Error("Error! Unknown operating system.");
    }

    const app: Application = new Application(factory);
    app.createUI();
    app.paint();
  }
}
```

In the example above, interfaces were defined for the product types `Button` and `Checkbox`. These products have two variants, depending on the operating system they are intended for, forming a family of either Windows or Mac products.  

The abstract factory `GUIFactory` is responsible for declaring the interface for creating these products. Its corresponding concrete factories are designed to generate products belonging to the same family: `WinFactory` for Windows-specific components (`WinButton`, `WinCheckbox`) and `MacFactory` for Mac-specific components (`MacButton`, `MacCheckbox`).  

As required by the pattern, each product variant has a corresponding concrete class. This is reflected in the implementation of `WinCheckbox`, `WinButton`, `MacCheckbox`, and `MacButton`. The client code remains agnostic about which factory or product it is using, while the factory guarantees that all created products belong to the same family, ensuring consistency.  

The `ApplicationConfigurator` can now instantiate the appropriate factory based on the operating system, just as previously done using the factory method pattern. This allows the application to dynamically select the correct set of UI components without modifying its core logic.      

The Abstract Factory is well-suited for scenarios where:  

- The code should be designed to handle families of related products without relying on their specific classes. This ensures future extensibility and allows it to function effectively even when the products are unknown in advance.
- Consider using the Abstract Factory pattern when a class contains multiple Factory Methods that obscure its main responsibility.

### Benefits and Drawbacks

- ✅ Confidence in the compatibility of the products obtained from the factory.
- ✅ Prevents tight coupling between concrete products and client code.
- ✅ The product creation logic can be centralized in a single location, making the code easier to maintain and support while adhering to the Single Responsibility Principle (SRP).
- ✅ New product variants can be introduced into the code without disrupting existing client code.
- ❌ The code can become much more complex than necessary when several new interfaces and classes are introduced alongside the pattern.

## 🏗️ Builder

The **Builder** pattern is a creational design pattern that enables the step-by-step construction of complex objects, allowing different types and representations to be created using the same construction code. When working with complex objects, creating subclasses or embedding all necessary parameters in the constructor can be challenging, leading to messy and hard-to-maintain code. Instead of constructing the object all at once, the **Builder** pattern suggests breaking the process into smaller steps, much like building a house. It delegates the construction logic to separate builder objects (_builders_), making the code cleaner and more maintainable. To create an object, a series of steps must be executed on a builder object. Not all steps are required, allowing only the necessary steps to be performed for constructing a specific configuration of the object. 

The builder object can be called directly in the client code, but the sequence of builder steps to construct a product can also be extracted into a separate class called a _director_. This way, the builder handles the construction steps, while the director class defines the order in which the necessary steps are executed to create the product. While a director class is not mandatory, it provides a convenient place to organize various construction routines, making them reusable across the application. Another benefit is that the client code only needs to associate a builder with a director and execute the construction process through the director to obtain the result from the builder, with all details of the product construction fully hidden. To be fully implemented, the Builder pattern requires a Builder interface, a Director class, Concrete Builder classes, and Product classes, which represent the products being constructed by each builder.

- **Builder interface**: declares the essential construction steps common to all types of builders.
- **Concrete Builders**: provide different implementations of the construction steps and may produce products that do not adhere to the common interface.
- **Products**: the objects being constructed. Products created by different builders do not need to belong to the same class hierarchy or implement the same interface. 
- **Director**: defines the order of execution for the construction steps, enabling the creation and reuse of specific product configurations.

**Note**: The client code must associate a builder object with the director. However, the client can pass the builder object directly to the director's production method, allowing for the use of a different builder each time the director produces something.

### Car Builder example

> TypeScript implementation of the pseudocode presented on pages 115 to 119 in *Dive Into Design Patterns* by Alexander Shvets. Refactoring.Guru, 2022. Available at: [https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book).

**PS**: Excluding the manual from the implementation for brevity - no one reads it anyway! 📖😆. Note that the pattern allows creating products with different interfaces—for example, the manual relates to the car but has a distinct interface. While the same builder methods can construct both, their structure and purpose differ, showcasing the pattern’s flexibility in producing related yet distinct products.

```typescript
class GPS {
  name: string = "gps";
}

class TripComputer {
  name: string = "trip_computer";
}

class Engine {
  name: string = "engine";
}

class SportsEngine extends Engine {
  name: string = "sports_engine";
}

// Product class
class Car {
  private seatsQuantity!: number;
  private gps!: GPS;
  private tripComputer!: TripComputer;
  private engine!: Engine;

  constructor() {}

  setSeats(quantity: number) {
    this.seatsQuantity = quantity;
  }

  setGPS(gps: GPS) {
    this.gps = gps;
  }

  setTripComputer(tripComputer: TripComputer) {
    this.tripComputer = tripComputer;
  }

  setEngine(engine: Engine) {
    this.engine = engine;
  }

  describe() {
    console.log(
      `A car with ${this.seatsQuantity} seats, a ${this.gps.name}, an ${this.engine.name}, and a ${this.tripComputer.name}`,
    );
  }
}

// Builder interface
interface Builder {
  reset(): void;
  setSeats(quantity: number): void;
  setEngine(engine: Engine): void;
  setTripComputer(set: boolean): void;
  setGPS(set: boolean): void;
}

// Concrete builder
class CarBuilder implements Builder {
  private car!: Car;

  constructor() {
    this.reset();
  }

  reset(): void {
    this.car = new Car();
  }

  setSeats(quantity: number): void {
    this.car.setSeats(quantity);
  }

  setEngine(engine: Engine): void {
    this.car.setEngine(engine);
  }

  setTripComputer(set: boolean): void {
    set && this.car.setTripComputer(new TripComputer());
  }

  setGPS(set: boolean): void {
    set && this.car.setGPS(new GPS());
  }

  getProduct(): Car {
    const product = this.car;
    this.reset();
    return product;
  }
}

// Director class (optional)
class Director {
  constructSportsCar(builder: Builder) {
    builder.reset();
    builder.setSeats(2);
    builder.setEngine(new SportsEngine());
    builder.setTripComputer(true);
    builder.setGPS(true);
  }
}

// Client code
class Application {
  makeCar() {
    const director = new Director();
    const carBuilder = new CarBuilder();
    director.constructSportsCar(carBuilder);
    const car = carBuilder.getProduct();
    car.describe();
  }
}
```

In the example above, a `Director` was used to construct a sports car, coordinating the `CarBuilder` to define the car's construction process. While the client code could have used the builder directly, leveraging the Director enhances code reusability. By using the Director, we can easily reuse the construction logic for a sports car throughout the application, promoting cleaner, more maintainable code.     

The Builder is well-suited for scenarios where:  

- There is an overload of a constructor with numerous optional parameters.
- The ability to create different representations of a product is needed.
- It is necessary to construct complex objects.

### Benefits and Drawbacks

- ✅ You can build objects incrementally, delay certain steps, or execute steps recursively.
- ✅ You can reuse the same construction code to create different representations of products.
- ✅ You can isolate complex construction code from the product's business logic, adhering to the Single Responsibility Principle (SRP).
- ❌ Requires the creation of several new classes, which increases its overall complexity.

## 🔄 Prototype

The **Prototype** pattern is a creational design pattern that allows objects to be copied without coupling the code to their classes. If an exact copy of an object is needed, one might consider creating a new instance of the same class and copying each value from the original object. However, this approach has several drawbacks:

- Some fields may be private and inaccessible outside the object's scope.
- The code becomes dependent on the original object's class, requiring the creation of a new instance and copying values manually.
- In some cases, only the object's interface is known, not its concrete class, which is required for copying.

The **Prototype** pattern addresses this issue by delegating the cloning process to the objects themselves, providing a common interface for all objects that support cloning. The clone interface typically defines a single method, `clone`, which is implemented similarly across all classes that implement the interface. This method creates a new object of the same class and copies all field values from the original, including private fields, which is possible in most programming languages that allow objects to access the private fields of other objects within the same class. An object that supports cloning is referred to as a _prototype_.

A basic implementation of the pattern involves:

- *Prototype*: interface that declares the cloning methods - usually, it's a single `clone` method.
- *Concrete Prototype*: a class that implements the cloning method. The implementation must address edge cases, such as linked objects and recursive dependencies.

The client code can now clone any object that follows the prototype interface. Additionally, a *Prototype Registry* can provide easy access to frequently used objects by storing a set of pre-built objects ready for cloning. 

### Shapes example

> TypeScript implementation of the pseudocode presented on pages 130 to 133 in *Dive Into Design Patterns* by Alexander Shvets. Refactoring.Guru, 2022. Available at: [https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book).

```typescript
// Base Prototype
abstract class Shape {
  x!: number;
  y!: number;
  color!: string;

  constructor();
  constructor(source: Shape);

  constructor(source?: Shape) {
    if (source) {
      this.x = source.x;
      this.y = source.y;
      this.color = source.color;
    }
  }

  abstract clone(): Shape;
}

// Concrete Prototype
class Rectangle extends Shape {
  width!: number;
  height!: number;

  constructor();
  constructor(source: Rectangle);

  constructor(source?: Rectangle) {
    super(source!);
    if (source) {
      this.width = source.width;
      this.height = source.height;
    }
  }

  clone(): Shape {
    return new Rectangle(this);
  }
}

class Circle extends Shape {
  radius!: number;

  constructor();
  constructor(source: Circle);

  constructor(source?: Circle) {
    super(source!);
    if (source) {
      this.radius = source.radius;
    }
  }

  clone(): Shape {
    return new Circle(this);
  }
}

// Client code
class Application {
  shapes: Shape[] = [];

  constructor() {
    const circle: Circle = new Circle();
    circle.x = 10;
    circle.y = 10;
    circle.radius = 20;
    this.shapes.push(circle);

    const anotherCircle = circle.clone();
    this.shapes.push(anotherCircle);

    const rectangle = new Rectangle();
    rectangle.width = 10;
    rectangle.height = 20;
    this.shapes.push(rectangle);
  }

  businessLogic() {
    const shapesCopy: Shape[] = [];
    this.shapes.forEach((shape) => {
      shapesCopy.push(shape.clone());
    });
  }
}

const app = new Application();
app.businessLogic();
```

In the example above, a base interface for geometric shapes is defined. The **Shape** class is responsible for declaring the `clone` method and managing class construction assignments. Additionally, two concrete prototypes were defined: one for representing rectangles (the **Rectangle** class) and another for representing circles (the **Circle** class). In the implementation of the `clone` method within the concrete classes, a new object is returned, and a reference to the original object is passed to the constructor. This allows the fields of the original object to be copied during initialization. Note that with this implementation, the client code can now copy geometric shapes through the `clone` method without needing to know the concrete implementations of circles and rectangles. It only relies on the interface provided by the **Shape** interface.

The Prototype is well-suited for scenarios where:  

- The code should not rely on the concrete classes of the objects that need to be cloned.
- It is desirable to minimize the number of subclasses that differ only in how their objects are initialized.

### Benefits and Drawbacks

- ✅ Objects can be copied without being tied to their concrete classes.
- ✅ Allows for the elimination of redundant initialization code by cloning pre-built prototypes instead.
- ✅ Offers a more efficient way to create complex objects.
- ✅ Provides an alternative to inheritance when managing configuration presets for complex objects.
- ❌ Cloning objects with circular references can be quite challenging.

## 👑 Singleton

The **Singleton** pattern is a creational design pattern that guarantees a class has a single instance and provides a global access point to it. The **Singleton** pattern defines a static method (`getInstance`) that returns the same instance of the class, ensuring only one instance exists. The class constructor is kept private, preventing direct instantiation from client code. This guarantees that the application can access a single instance of the class globally, wherever the `getInstance` method is invoked.

### Database example

> TypeScript implementation of the pseudocode presented on pages 142 and 143 in *Dive Into Design Patterns* by Alexander Shvets. Refactoring.Guru, 2022. Available at: [https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book).

```typescript
class Database {
  private static instance: Database;

  private constructor() {
    console.log("Database initialized");
  }

  static getInstance() {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  query(sql: string) {
    console.log(`Query ${sql} executed`);
  }
}

class Application {
  main() {
    const foo = Database.getInstance();
    foo.query("SELECT * FROM table_1");

    const bar = Database.getInstance();
    bar.query("SELECT * FROM table_2");
  }
}
```

In the example above, the **Database** class does not have a public constructor. The only way to obtain an instance of this class is by calling the `getInstance` method, which caches the first created instance and returns the same instance for all subsequent calls.      

The Singleton is well-suited for scenarios where:  

- A class in the program must have a single instance that is used throughout the application.
- Stricter control over global variables is required.

### Benefits and Drawbacks

- ✅ Ensures the existence of only one single instance of a class.
- ✅ Provides global access point to the single instance.
- ✅ Initialization of the object occurs only on the firt time.
- ❌ Violates the SRP (Single Responsibility Principle), by solving two problems at the same time: global access and the existence of only one instance.
- ❌ Can obscure poor design, especially when program components have excessive dependencies on each other.
- ❌ Requires special handling in a multithreading environment.
- ❌ Makes writing unit tests challenging because the constructor is private, and overriding the static method is typically not possible in most programming languages.

## References

* Book reference: [Dive Into Design Patterns](https://refactoring.guru/design-patterns/book) by Alexander Shvets, Refactoring.Guru, 2022, pages 71-146.
